// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title AccessRegistry
 * @dev Manages access control events and content hashes for off-chain data.
 */
contract AccessRegistry {
    // Events
    event AccessRequested(bytes32 indexed contentHash, address indexed requester, string purpose);
    event AccessGranted(bytes32 indexed contentHash, address indexed owner, address indexed grantee, uint256 expiresAt, string purpose, bytes encryptedKey);
    event AccessRevoked(bytes32 indexed contentHash, address indexed owner, address indexed grantee);
    event DataModified(bytes32 indexed contentHashBefore, bytes32 indexed contentHashAfter, address indexed modifier, uint256 timestamp, string changeSummary);
    event DataUploaded(bytes32 indexed contentHash, address indexed owner, uint256 timestamp);

    // Mappings to track ownership (optional, for validation)
    mapping(bytes32 => address) public contentOwner;

    /**
     * @notice Register new uploaded content
     * @param contentHash The hash of the encrypted content (CID or SHA256)
     */
    function registerContent(bytes32 contentHash) external {
        require(contentOwner[contentHash] == address(0), "Content already registered");
        contentOwner[contentHash] = msg.sender;
        emit DataUploaded(contentHash, msg.sender, block.timestamp);
    }

    /**
     * @notice Request access to specific content
     * @param contentHash The hash of the content
     * @param purpose The reason for requesting access
     */
    function requestAccess(bytes32 contentHash, string calldata purpose) external {
        emit AccessRequested(contentHash, msg.sender, purpose);
    }

    /**
     * @notice Grant access to a requester
     * @param contentHash The hash of the content
     * @param grantee The address of the institution/user being granted access
     * @param expiresAt Timestamp when access expires
     * @param purpose The purpose string (should match request)
     * @param encryptedKey The symmetric key encrypted with grantee's public key
     */
    function grantAccess(
        bytes32 contentHash,
        address grantee,
        uint256 expiresAt,
        string calldata purpose,
        bytes calldata encryptedKey
    ) external {
        require(contentOwner[contentHash] == msg.sender, "Only owner can grant access");
        emit AccessGranted(contentHash, msg.sender, grantee, expiresAt, purpose, encryptedKey);
    }

    /**
     * @notice Revoke access
     * @param contentHash The hash of the content
     * @param grantee The address to revoke access from
     */
    function revokeAccess(bytes32 contentHash, address grantee) external {
        require(contentOwner[contentHash] == msg.sender, "Only owner can revoke access");
        emit AccessRevoked(contentHash, msg.sender, grantee);
    }

    /**
     * @notice Record a modification to data
     * @param contentHashBefore The original content hash
     * @param contentHashAfter The new content hash
     * @param changeSummary A brief summary of changes (generated by AI or user)
     */
    function modifyData(
        bytes32 contentHashBefore,
        bytes32 contentHashAfter,
        string calldata changeSummary
    ) external {
        // In a real system, we would check if msg.sender has 'can_modify' permission.
        // Since logic is off-chain, we rely on the backend/owner to validate or 
        // we could store permissions on-chain (more gas). 
        // For this prototype, we assume the caller is authorized or the owner.
        // Ideally, the owner calls this, or a contract with delegated permissions.
        
        // For simplicity in this prototype: Only allow owner to commit changes 
        // (Institution sends signed update to Owner, or Institution is delegated).
        // Let's assume the Institution calls this and we trust the event emission 
        // or the backend verifies the signature before submitting.
        
        // Check if new hash is fresh
        require(contentOwner[contentHashAfter] == address(0), "New content hash already exists");

        emit DataModified(contentHashBefore, contentHashAfter, msg.sender, block.timestamp, changeSummary);
        
        // Transfer ownership to modifier or keep original? 
        // Usually original owner stays owner, or it's a new version.
        // Let's map the new hash to the msg.sender (modifier) for now, 
        // or ideally the original owner if we tracked it.
        contentOwner[contentHashAfter] = msg.sender; 
    }
}
